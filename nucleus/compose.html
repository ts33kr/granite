<!DOCTYPE html><html lang="en"><head><title>nucleus/compose</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="nucleus/compose"><meta name="groc-project-path" content="library/nucleus/compose.coffee"><meta name="groc-github-url" content="https://github.com/ts33kr/granite"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/ts33kr/granite/blob/master/library/nucleus/compose.coffee">library/nucleus/compose.coffee</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="cm">###</span>
<span class="cm">Copyright (c) 2013, Alexander Cherniuk &lt;ts33kr@gmail.com&gt;</span>
<span class="cm">All rights reserved.</span>

<span class="cm">Redistribution and use in source and binary forms, with or without</span>
<span class="cm">modification, are permitted provided that the following conditions are met:</span>

<span class="cm">1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="cm">   list of conditions and the following disclaimer.</span>
<span class="cm">2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="cm">   this list of conditions and the following disclaimer in the documentation</span>
<span class="cm">   and/or other materials provided with the distribution.</span>

<span class="cm">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<span class="cm">ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="cm">WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="cm">DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR</span>
<span class="cm">ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="cm">(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="cm">LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="cm">ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm">(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="cm">SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm">###</span>

<span class="nv">_ = </span><span class="nx">require</span> <span class="s">&quot;lodash&quot;</span>
<span class="nv">async = </span><span class="nx">require</span> <span class="s">&quot;async&quot;</span>
<span class="nv">asciify = </span><span class="nx">require</span> <span class="s">&quot;asciify&quot;</span>
<span class="nv">connect = </span><span class="nx">require</span> <span class="s">&quot;connect&quot;</span>
<span class="nv">logger = </span><span class="nx">require</span> <span class="s">&quot;winston&quot;</span>
<span class="nv">events = </span><span class="nx">require</span> <span class="s">&quot;eventemitter2&quot;</span>
<span class="nv">colors = </span><span class="nx">require</span> <span class="s">&quot;colors&quot;</span>
<span class="nv">assert = </span><span class="nx">require</span> <span class="s">&quot;assert&quot;</span>
<span class="nv">nconf = </span><span class="nx">require</span> <span class="s">&quot;nconf&quot;</span>
<span class="nv">https = </span><span class="nx">require</span> <span class="s">&quot;https&quot;</span>
<span class="nv">http = </span><span class="nx">require</span> <span class="s">&quot;http&quot;</span>
<span class="nv">util = </span><span class="nx">require</span> <span class="s">&quot;util&quot;</span>

<span class="p">{</span><span class="nx">remote</span><span class="p">}</span> <span class="o">=</span> <span class="nx">require</span> <span class="s">&quot;../membrane/remote&quot;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>This class contains the definition of the dynamic recomposition
system. The reason this class exists is to encapsulate this system
and make it possible to use it on the remote call site. The system
is a derivative approach from the mixin. It allows to dynamically
recombinate the inheritance tree to include any number of compounds.</p></div></div><div class="code"><div class="wrapper"><span class="nv">module.exports.Composition = </span><span class="nx">remote</span> <span class="nf">-&gt;</span> <span class="k">class</span> <span class="nx">Composition</span> <span class="k">extends</span> <span class="nb">Object</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>This method exists as a complementary part of the composition
system. The cloner is an implementation of the shader that is
mapped over each node of the linear hierarchy of the class that
invokes the composition functionality to obtain a shadow of the
original class that can be later modified to modify hierarchy.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">cloner = </span><span class="nx">module</span><span class="o">?</span><span class="p">.</span><span class="nx">exports</span><span class="o">?</span><span class="p">.</span><span class="nv">cloner = </span><span class="nf">(subject) -&gt;</span>
        <span class="nv">noClass = </span><span class="s">&quot;the suplied subject is not a class&quot;</span>
        <span class="nx">assert</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isObject</span><span class="p">(</span><span class="nx">subject</span><span class="o">?</span><span class="p">.</span><span class="nx">__super__</span><span class="p">),</span> <span class="nx">noClass</span>
        <span class="nv">subject = </span><span class="nx">subject</span><span class="p">.</span><span class="nx">watermark</span> <span class="k">if</span> <span class="nx">subject</span><span class="p">.</span><span class="nx">watermark</span>
        <span class="nv">snapshot = </span><span class="nx">_</span><span class="p">.</span><span class="nx">cloneDeep</span> <span class="nx">subject</span><span class="p">,</span> <span class="nv">d = </span><span class="nf">(value) -&gt;</span>
            <span class="k">return</span> <span class="k">unless</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isFunction</span> <span class="nx">value</span> <span class="o">or</span> <span class="mi">0</span>
            <span class="nv">func = </span><span class="nf">-&gt;</span> <span class="nx">value</span><span class="p">.</span><span class="nx">apply</span> <span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span>
            <span class="nv">func.name = </span><span class="nx">value</span><span class="p">.</span><span class="nx">name</span> <span class="o">or</span> <span class="s">&quot;&lt;anonymous&gt;&quot;</span>
            <span class="nx">_</span><span class="p">.</span><span class="nx">extend</span> <span class="nx">func</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">value</span><span class="p">.</span><span class="nx">prototype</span>
            <span class="nv">func.constructor = </span><span class="nx">value</span><span class="p">.</span><span class="nx">constructor</span><span class="p">;</span> <span class="nx">func</span>
        <span class="nv">w = get: </span><span class="nf">-&gt;</span> <span class="nx">assert</span> <span class="o">not</span> <span class="nx">subject</span><span class="p">.</span><span class="nx">watermark</span><span class="p">;</span> <span class="nx">subject</span>
        <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span> <span class="nx">snapshot</span><span class="p">,</span> <span class="s">&quot;watermark&quot;</span><span class="p">,</span> <span class="nx">w</span>
        <span class="nx">assert</span> <span class="nx">snapshot</span><span class="p">.</span><span class="nx">watermark</span><span class="p">;</span> <span class="k">return</span> <span class="nx">snapshot</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>A unique functionality built around the composition system. It
allows for an asynchronous way of calling a stream of methods,
each defined in the peer of the inheritance tree. Basically this
is a utility to asynchronously call super methods down the stack.
Each method must call its last parameter <code>next</code> for proceeding.
Use <code>async</code> error propagation mechanism to break out of stream.</p></div></div><div class="code"><div class="wrapper">    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span> <span class="nb">Object</span><span class="o">::</span><span class="p">,</span> <span class="s">&quot;downstream&quot;</span><span class="p">,</span>
        <span class="nv">enumerable: </span><span class="kc">no</span><span class="p">,</span> <span class="nv">value: </span><span class="nf">(def) -&gt;</span> <span class="nf">(args...) =&gt;</span>
            <span class="nv">fx = </span><span class="nf">(f) =&gt;</span> <span class="nf">(a...) =&gt;</span> <span class="nx">f</span><span class="p">.</span><span class="nx">apply</span> <span class="nx">@</span><span class="p">,</span> <span class="nx">cc</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
            <span class="nv">cc = </span><span class="nf">(a) -&gt;</span> <span class="nx">_</span><span class="p">.</span><span class="nx">toArray</span><span class="p">(</span><span class="nx">args</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
            <span class="nv">malformed = </span><span class="s">&quot;no POJO style definition&quot;</span>
            <span class="nx">assert</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isPlainObject</span> <span class="nx">def</span><span class="p">,</span> <span class="nx">malformed</span>
            <span class="nx">assert</span> <span class="nv">targeted = </span><span class="nx">_</span><span class="p">.</span><span class="nx">head</span> <span class="nx">_</span><span class="p">.</span><span class="nx">keys</span> <span class="nx">def</span>
            <span class="nx">assert</span> <span class="nv">callback = </span><span class="nx">_</span><span class="p">.</span><span class="nx">head</span> <span class="nx">_</span><span class="p">.</span><span class="nx">values</span> <span class="nx">def</span>
            <span class="nv">hierarchy = </span><span class="nx">@constructor</span><span class="p">.</span><span class="nx">hierarchy</span><span class="p">()</span>
            <span class="nx">assert</span> <span class="nx">hierarchy</span><span class="p">.</span><span class="nx">unshift</span> <span class="nx">@constructor</span>
            <span class="nv">resolve = </span><span class="nf">(c) -&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">prototype</span><span class="o">?</span><span class="p">[</span><span class="nx">targeted</span><span class="p">]</span>
            <span class="nx">assert</span> <span class="nv">threads = </span><span class="nx">_</span><span class="p">.</span><span class="nx">map</span> <span class="nx">hierarchy</span><span class="p">,</span> <span class="nx">resolve</span>
            <span class="nv">methods = </span><span class="nx">_</span><span class="p">.</span><span class="nx">filter</span> <span class="nx">threads</span><span class="p">,</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isFunction</span>
            <span class="nv">prepped = </span><span class="nx">_</span><span class="p">.</span><span class="nx">unique</span> <span class="nx">methods</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>
            <span class="nv">applied = </span><span class="nx">_</span><span class="p">.</span><span class="nx">map</span> <span class="nx">prepped</span><span class="p">,</span> <span class="nf">(fn) -&gt;</span> <span class="nx">fx</span> <span class="nx">fn</span>
            <span class="nv">bounded = </span><span class="nx">callback</span><span class="o">?</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">or</span> <span class="p">(</span><span class="nf">-&gt;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nx">async</span><span class="p">.</span><span class="nx">series</span> <span class="nx">applied</span><span class="p">,</span> <span class="nx">bounded</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>A unique functionality built around the composition system. It
allows for an asynchronous way of calling a stream of methods,
each defined in the peer of the inheritance tree. Basically this
is a utility to asynchronously call super methods up the stack.
Each method must call its last parameter <code>next</code> for proceeding.
Use <code>async</code> error propagation mechanism to break out of stream.</p></div></div><div class="code"><div class="wrapper">    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span> <span class="nb">Object</span><span class="o">::</span><span class="p">,</span> <span class="s">&quot;upstream&quot;</span><span class="p">,</span>
        <span class="nv">enumerable: </span><span class="kc">no</span><span class="p">,</span> <span class="nv">value: </span><span class="nf">(def) -&gt;</span> <span class="nf">(args...) =&gt;</span>
            <span class="nv">fx = </span><span class="nf">(f) =&gt;</span> <span class="nf">(a...) =&gt;</span> <span class="nx">f</span><span class="p">.</span><span class="nx">apply</span> <span class="nx">@</span><span class="p">,</span> <span class="nx">cc</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
            <span class="nv">cc = </span><span class="nf">(a) -&gt;</span> <span class="nx">_</span><span class="p">.</span><span class="nx">toArray</span><span class="p">(</span><span class="nx">args</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
            <span class="nv">malformed = </span><span class="s">&quot;no POJO style definition&quot;</span>
            <span class="nx">assert</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isPlainObject</span> <span class="nx">def</span><span class="p">,</span> <span class="nx">malformed</span>
            <span class="nx">assert</span> <span class="nv">targeted = </span><span class="nx">_</span><span class="p">.</span><span class="nx">head</span> <span class="nx">_</span><span class="p">.</span><span class="nx">keys</span> <span class="nx">def</span>
            <span class="nx">assert</span> <span class="nv">callback = </span><span class="nx">_</span><span class="p">.</span><span class="nx">head</span> <span class="nx">_</span><span class="p">.</span><span class="nx">values</span> <span class="nx">def</span>
            <span class="nv">hierarchy = </span><span class="nx">@constructor</span><span class="p">.</span><span class="nx">hierarchy</span><span class="p">()</span>
            <span class="nx">assert</span> <span class="nx">hierarchy</span><span class="p">.</span><span class="nx">unshift</span> <span class="nx">@constructor</span>
            <span class="nv">resolve = </span><span class="nf">(c) -&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">prototype</span><span class="o">?</span><span class="p">[</span><span class="nx">targeted</span><span class="p">]</span>
            <span class="nx">assert</span> <span class="nv">threads = </span><span class="nx">_</span><span class="p">.</span><span class="nx">map</span> <span class="nx">hierarchy</span><span class="p">,</span> <span class="nx">resolve</span>
            <span class="nv">methods = </span><span class="nx">_</span><span class="p">.</span><span class="nx">filter</span> <span class="nx">threads</span><span class="p">,</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isFunction</span>
            <span class="nv">prepped = </span><span class="nx">_</span><span class="p">.</span><span class="nx">toArray</span> <span class="nx">_</span><span class="p">.</span><span class="nx">unique</span> <span class="nx">methods</span>
            <span class="nv">applied = </span><span class="nx">_</span><span class="p">.</span><span class="nx">map</span> <span class="nx">prepped</span><span class="p">,</span> <span class="nf">(fn) -&gt;</span> <span class="nx">fx</span> <span class="nx">fn</span>
            <span class="nv">bounded = </span><span class="nx">callback</span><span class="o">?</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">or</span> <span class="p">(</span><span class="nf">-&gt;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nx">async</span><span class="p">.</span><span class="nx">series</span> <span class="nx">applied</span><span class="p">,</span> <span class="nx">bounded</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>A method for comparing different classes for equality. Be careful
as this method is very loose in terms of comparison and its main
purpose is aiding in implementation of the composition mechanism
rather than any else. Comparison algorithms is likely to change.</p></div></div><div class="code"><div class="wrapper">    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span> <span class="nb">Object</span><span class="o">::</span><span class="p">,</span> <span class="s">&quot;similarWith&quot;</span><span class="p">,</span>
        <span class="nv">enumerable: </span><span class="kc">no</span><span class="p">,</span> <span class="nv">value: </span><span class="nf">(archetype, loose) -&gt;</span>
            <span class="nv">isClass = </span><span class="nx">_</span><span class="p">.</span><span class="nx">isObject</span> <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span>
            <span class="nv">noClass = </span><span class="s">&quot;The subject is not a class&quot;</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span> <span class="nx">noClass</span> <span class="k">unless</span> <span class="nx">isClass</span>
            <span class="k">return</span> <span class="kc">yes</span> <span class="k">if</span> <span class="k">this</span> <span class="o">is</span> <span class="nx">archetype</span> <span class="o">or</span> <span class="kc">no</span>
            <span class="k">return</span> <span class="kc">yes</span> <span class="k">if</span> <span class="nx">@watermark</span> <span class="o">is</span> <span class="nx">archetype</span>
            <span class="k">return</span> <span class="kc">undefined</span> <span class="k">unless</span> <span class="nx">loose</span> <span class="o">is</span> <span class="kc">yes</span>
            <span class="k">return</span> <span class="kc">yes</span> <span class="k">if</span> <span class="nx">@name</span> <span class="o">is</span> <span class="nx">archetype</span><span class="p">.</span><span class="nx">name</span>
            <span class="k">return</span> <span class="kc">yes</span> <span class="k">if</span> <span class="nx">@nick</span> <span class="o">is</span> <span class="nx">archetype</span><span class="p">.</span><span class="nx">nick</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>A method for the dynamic lookup of the super methods. This method
exists because CoffeeScript resolves super methods by using static
hardcoded class names and <strong>super</strong> attributes. But in order for
composition to work - system needs dynamic super method resolution.
Call this method with current class and the method name arguments</p></div></div><div class="code"><div class="wrapper">    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span> <span class="nb">Object</span><span class="o">::</span><span class="p">,</span> <span class="s">&quot;upstack&quot;</span><span class="p">,</span>
        <span class="nv">enumerable: </span><span class="kc">no</span><span class="p">,</span> <span class="nv">value: </span><span class="nf">(definition) -&gt;</span>
            <span class="nv">wrong = </span><span class="s">&quot;invalid POJO style definition&quot;</span>
            <span class="nx">assert</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isPlainObject</span> <span class="nx">definition</span><span class="p">,</span> <span class="nx">wrong</span>
            <span class="nx">assert</span> <span class="nv">nameing = </span><span class="nx">_</span><span class="p">.</span><span class="nx">head</span> <span class="nx">_</span><span class="p">.</span><span class="nx">keys</span> <span class="nx">definition</span>
            <span class="nx">assert</span> <span class="nv">exclude = </span><span class="nx">_</span><span class="p">.</span><span class="nx">head</span> <span class="nx">_</span><span class="p">.</span><span class="nx">values</span> <span class="nx">definition</span>
            <span class="nx">assert</span> <span class="nv">current = </span><span class="k">this</span><span class="p">[</span><span class="nx">nameing</span><span class="p">]</span> <span class="o">or</span> <span class="kc">undefined</span>
            <span class="nx">assert</span> <span class="nv">hierarchy = </span><span class="nx">@constructor</span><span class="p">.</span><span class="nx">hierarchy</span><span class="p">()</span>
            <span class="nv">predicate = </span><span class="nf">(co) -&gt;</span> <span class="nx">co</span><span class="p">.</span><span class="nx">similarWith</span> <span class="nx">exclude</span>
            <span class="nv">pivotal = </span><span class="nx">_</span><span class="p">.</span><span class="nx">findIndex</span> <span class="nx">hierarchy</span><span class="p">,</span> <span class="nx">predicate</span>
            <span class="nv">hierarchy = </span><span class="nx">_</span><span class="p">.</span><span class="nx">drop</span> <span class="nx">hierarchy</span><span class="p">,</span> <span class="nx">pivotal</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="nv">exists = </span><span class="nf">(val) -&gt;</span> <span class="nx">val</span><span class="p">.</span><span class="nx">prototype</span><span class="o">?</span><span class="p">[</span><span class="nx">nameing</span><span class="p">]</span><span class="o">?</span>
            <span class="nv">heading = </span><span class="nx">_</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">hierarchy</span><span class="p">,</span> <span class="nx">exists</span><span class="p">)</span> <span class="o">or</span> <span class="mi">0</span>
            <span class="nv">value = </span><span class="k">try</span> <span class="nx">heading</span><span class="o">?</span><span class="p">.</span><span class="nx">prototype</span><span class="o">?</span><span class="p">[</span><span class="nx">nameing</span><span class="p">]</span>
            <span class="k">return</span> <span class="nx">value</span> <span class="k">unless</span>  <span class="nx">value</span> <span class="o">is</span> <span class="nx">current</span>
            <span class="p">(</span><span class="nv">formed = </span><span class="p">{})[</span><span class="nx">nameing</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">head</span><span class="p">(</span><span class="nx">hierarchy</span><span class="p">)</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">upstack</span><span class="p">.</span><span class="nx">call</span> <span class="k">this</span><span class="p">,</span> <span class="nx">formed</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>A complicated piece of functionality for merging arbitrary classes
into the linear hierarchical inheritance chain of existing class.
This method integrated the supplied compound class in the tear in
between the foreign and common peers in the inheritance chain. Do
refer to the implementation for the understanding of what happens.</p></div></div><div class="code"><div class="wrapper">    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span> <span class="nb">Object</span><span class="o">::</span><span class="p">,</span> <span class="s">&quot;compose&quot;</span><span class="p">,</span>
        <span class="nv">enumerable: </span><span class="kc">no</span><span class="p">,</span> <span class="nv">value: </span><span class="nf">(compound, shader=cloner) -&gt;</span>
            <span class="nx">assert</span> <span class="nv">foreign = </span><span class="k">try</span> <span class="nx">compound</span><span class="p">.</span><span class="nx">hierarchy</span><span class="p">()</span>
            <span class="nx">assert</span> <span class="nv">identify = </span><span class="k">try</span> <span class="nx">compound</span><span class="p">.</span><span class="nx">identify</span><span class="p">()</span>
            <span class="nv">cmp = </span><span class="nf">(orig) -&gt;</span> <span class="nf">(cs) -&gt;</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">similarWith</span> <span class="nx">orig</span>
            <span class="nv">common = </span><span class="nf">(value) -&gt;</span> <span class="nx">_</span><span class="p">.</span><span class="nx">any</span> <span class="nx">foreign</span><span class="p">,</span> <span class="nx">cmp</span> <span class="nx">value</span>
            <span class="nv">culrpit = </span><span class="nf">(pvo) -&gt;</span> <span class="o">not</span> <span class="nx">_</span><span class="p">.</span><span class="nx">any</span> <span class="nx">commons</span><span class="p">,</span> <span class="nx">cmp</span> <span class="nx">pvo</span>
            <span class="nv">notAbstract = </span><span class="s">&quot;the </span><span class="si">#{</span><span class="nx">identify</span><span class="si">}</span><span class="s"> is not abstract&quot;</span>
            <span class="nv">orphans = </span><span class="s">&quot;no common base classes in hierarchy&quot;</span>
            <span class="nx">assert</span> <span class="nx">compound</span><span class="p">.</span><span class="nx">abstract</span><span class="o">?</span><span class="p">()</span> <span class="o">is</span> <span class="kc">yes</span><span class="p">,</span> <span class="nx">notAbstract</span>
            <span class="nv">commons = </span><span class="nx">_</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">@hierarchy</span><span class="p">(),</span> <span class="nx">common</span><span class="p">)</span> <span class="o">or</span> <span class="p">[]</span>
            <span class="nx">assert</span> <span class="o">not</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">(</span><span class="nx">commons</span><span class="p">),</span> <span class="nx">orphans</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
            <span class="nv">differentiated = </span><span class="nx">_</span><span class="p">.</span><span class="nx">take</span> <span class="nx">@hierarchy</span><span class="p">(),</span> <span class="nx">culrpit</span>
            <span class="nv">alternative = </span><span class="nx">_</span><span class="p">.</span><span class="nx">map</span> <span class="nx">differentiated</span> <span class="o">or</span> <span class="p">[],</span> <span class="nx">shader</span>
            <span class="nx">compound</span><span class="p">.</span><span class="nx">composition</span><span class="o">?</span> <span class="k">this</span><span class="p">,</span> <span class="nx">@hierarchy</span><span class="p">(),</span> <span class="nx">foreign</span>
            <span class="k">return</span> <span class="nx">@rebased</span> <span class="nx">compound</span> <span class="k">if</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isEmpty</span> <span class="nx">alternative</span>
            <span class="nx">assert</span> <span class="nv">tails = </span><span class="nx">alternative</span><span class="p">.</span><span class="nx">pop</span><span class="p">().</span><span class="nx">rebased</span> <span class="nx">compound</span>
            <span class="nv">rebased = </span><span class="nf">(acc, cls) -&gt;</span> <span class="nx">cls</span><span class="p">.</span><span class="nx">rebased</span> <span class="nx">acc</span><span class="p">;</span> <span class="nx">cls</span>
            <span class="nx">@rebased</span> <span class="nx">_</span><span class="p">.</span><span class="nx">foldr</span> <span class="nx">alternative</span><span class="p">,</span> <span class="nx">rebased</span><span class="p">,</span> <span class="nx">tails</span>
            <span class="k">return</span> <span class="nx">@refactoring</span> <span class="nx">compound</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>An important complementary part of the dynamic recomposition
system. The refactoring procedure is a recursive algorithm that
is executed after each composition invocation to refactor the
inheritance tree. The refactoring in this case is getting rid
of the indirectly or directly duplicated peers from the tree.</p></div></div><div class="code"><div class="wrapper">    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span> <span class="nb">Object</span><span class="o">::</span><span class="p">,</span> <span class="s">&quot;refactoring&quot;</span><span class="p">,</span>
        <span class="nv">enumerable: </span><span class="kc">no</span><span class="p">,</span> <span class="nv">value: </span><span class="nf">(trigger, shader=cloner) -&gt;</span>
            <span class="nv">cmp = </span><span class="nf">(peer) -&gt;</span> <span class="nx">peer</span><span class="p">.</span><span class="nx">watermark</span> <span class="o">or</span> <span class="nx">peer</span>
            <span class="nv">unique = </span><span class="nx">_</span><span class="p">.</span><span class="nx">unique</span> <span class="nv">h = </span><span class="nx">@hierarchy</span><span class="p">(),</span> <span class="nx">cmp</span>
            <span class="k">return</span> <span class="kc">null</span> <span class="k">if</span> <span class="nx">unique</span><span class="p">.</span><span class="nx">length</span> <span class="o">is</span> <span class="nx">h</span><span class="p">.</span><span class="nx">length</span>
            <span class="nx">assert</span> <span class="nv">outstanding = </span><span class="nx">_</span><span class="p">.</span><span class="nx">difference</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">unique</span>
            <span class="nv">target = </span><span class="nx">_</span><span class="p">.</span><span class="nx">head</span> <span class="nx">outstanding</span><span class="p">;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">unshift</span> <span class="k">this</span>
            <span class="nx">assert</span> <span class="nv">left = </span><span class="nf">-&gt;</span> <span class="nx">h</span><span class="p">[</span><span class="nx">_</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="nx">assert</span> <span class="nv">right = </span><span class="nf">-&gt;</span> <span class="nx">h</span><span class="p">[</span><span class="nx">_</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="nv">rebased = </span><span class="nf">(acc, c) -&gt;</span> <span class="nx">shader</span><span class="p">(</span><span class="nx">c</span><span class="p">).</span><span class="nx">rebased</span> <span class="nx">acc</span>
            <span class="nv">prefix = </span><span class="nx">_</span><span class="p">.</span><span class="nx">take</span> <span class="nx">_</span><span class="p">.</span><span class="nx">rest</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">_</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">left</span><span class="p">())</span>
            <span class="nx">@rebased</span> <span class="nx">_</span><span class="p">.</span><span class="nx">foldr</span> <span class="nx">prefix</span><span class="p">,</span> <span class="nx">rebased</span><span class="p">,</span> <span class="nx">target</span>
            <span class="nx">assert</span> <span class="p">(</span><span class="nv">h = </span><span class="k">this</span><span class="p">.</span><span class="nx">hierarchy</span><span class="p">()).</span><span class="nx">unshift</span> <span class="k">this</span>
            <span class="nv">shadow = </span><span class="nx">left</span><span class="p">().</span><span class="nx">watermark</span> <span class="o">or</span> <span class="p">(</span><span class="nx">left</span><span class="p">()</span> <span class="o">is</span> <span class="k">this</span><span class="p">)</span>
            <span class="nx">assert</span> <span class="nx">shadow</span><span class="p">,</span> <span class="s">&quot;original: </span><span class="si">#{</span><span class="nx">left</span><span class="p">().</span><span class="nx">identify</span><span class="p">()</span><span class="si">}</span><span class="s">&quot;</span>
            <span class="nx">left</span><span class="p">().</span><span class="nx">rebased</span> <span class="nx">right</span><span class="p">();</span> <span class="nx">@refactoring</span> <span class="nx">trigger</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Scan the supplied class and return an entire inheritance hierarchy
of classes. The hierarchy is represented as an array of prototypes
that follow in the order they appear in the chain: starting from
the supplied class and up to the top. The class has to be a valid
CoffeeScript class that posses all the necessary internal members.</p></div></div><div class="code"><div class="wrapper">    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span> <span class="nb">Object</span><span class="o">::</span><span class="p">,</span> <span class="s">&quot;hierarchy&quot;</span><span class="p">,</span>
        <span class="nv">enumerable: </span><span class="kc">no</span><span class="p">,</span> <span class="nv">value: </span><span class="nf">(subject) -&gt;</span>
            <span class="nx">assert</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isArray</span> <span class="nv">a = accumulate = </span><span class="k">new</span> <span class="nb">Array</span>
            <span class="nv">subject = </span><span class="k">this</span> <span class="k">unless</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isObject</span> <span class="k">try</span> <span class="nx">subject</span>
            <span class="nv">classed = </span><span class="nx">_</span><span class="p">.</span><span class="nx">isObject</span> <span class="nx">subject</span><span class="p">.</span><span class="nx">__super__</span> <span class="o">or</span> <span class="kc">null</span>
            <span class="nx">assert</span> <span class="nx">classed</span><span class="p">,</span> <span class="s">&quot;supplied object is not a class&quot;</span>
            <span class="nv">scanner = </span><span class="nf">(fn) -&gt;</span> <span class="nx">fn</span> <span class="nx">a</span> <span class="k">while</span> <span class="nx">subject</span><span class="o">?</span><span class="p">;</span> <span class="k">return</span> <span class="nx">a</span>
            <span class="k">return</span> <span class="nx">scanner</span> <span class="nx">_</span><span class="p">.</span><span class="nx">identity</span> <span class="nf">(accumulate) -&gt;</span> <span class="k">try</span>
                <span class="nv">subject = </span><span class="nx">subject</span><span class="p">.</span><span class="nx">__super__</span> <span class="o">or</span> <span class="kc">undefined</span>
                <span class="nv">constructor = </span><span class="nx">subject</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">or</span> <span class="kc">null</span>
                <span class="k">return</span> <span class="kc">no</span> <span class="k">unless</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isFunction</span> <span class="nx">constructor</span>
                <span class="nx">accumulate</span><span class="p">.</span><span class="nx">push</span> <span class="k">try</span> <span class="nv">subject = </span><span class="nx">constructor</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>A fancy method for dynamically changing the inheritance chain of
the existing classes. This method rebases the current class to
use the supplied base class as its direct ancestor. The supplied
class must conform to the basic class requirements, such as have
a valid <strong>super</strong> descriptor, among some other prototypal things.</p></div></div><div class="code"><div class="wrapper">    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span> <span class="nb">Object</span><span class="o">::</span><span class="p">,</span> <span class="s">&quot;rebased&quot;</span><span class="p">,</span>
        <span class="nv">enumerable: </span><span class="kc">no</span><span class="p">,</span> <span class="nv">value: </span><span class="nf">(baseclass, force) -&gt;</span>
            <span class="nv">classed = </span><span class="nx">_</span><span class="p">.</span><span class="nx">isObject</span> <span class="nx">baseclass</span><span class="o">?</span><span class="p">.</span><span class="nx">__super__</span>
            <span class="nv">malformed = </span><span class="s">&quot;the baseclass is not a class&quot;</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span> <span class="nx">malformed</span> <span class="k">unless</span> <span class="nx">classed</span>
            <span class="nx">baseclass</span><span class="p">.</span><span class="nx">rebasement</span><span class="o">?</span> <span class="k">this</span><span class="p">,</span> <span class="nx">force</span> <span class="o">or</span> <span class="kc">false</span>
            <span class="nv">p = </span><span class="nf">(key) =&gt;</span> <span class="nx">force</span> <span class="o">is</span> <span class="kc">yes</span> <span class="o">or</span> <span class="o">not</span> <span class="k">this</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="o">?</span>
            <span class="k">this</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span> <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">baseclass</span> <span class="k">when</span> <span class="nx">p</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
            <span class="nv">original = </span><span class="k">this</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">or</span> <span class="p">{};</span> <span class="nv">halo = </span><span class="k">this</span>
            <span class="o">`</span><span class="nx">function</span> <span class="nx">ctor</span><span class="p">()</span> <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nv">constructor = </span><span class="nx">halo</span><span class="p">}</span><span class="o">`</span>
            <span class="nx">assert</span> <span class="nv">ctor.prototype = </span><span class="nx">baseclass</span><span class="p">.</span><span class="nx">prototype</span>
            <span class="nx">assert</span> <span class="k">this</span><span class="p">.</span><span class="nv">__super__ = </span><span class="nx">baseclass</span><span class="p">.</span><span class="nx">prototype</span>
            <span class="k">try</span> <span class="k">this</span><span class="p">.</span><span class="nv">prototype = </span><span class="k">new</span> <span class="nx">ctor</span><span class="p">()</span> <span class="o">or</span> <span class="nx">original</span>
            <span class="nx">_</span><span class="p">.</span><span class="nx">extend</span> <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">original</span><span class="p">;</span> <span class="k">this</span></div></div></div></div></body></html>